classdef GibsonLaniPSFClass
    properties
        x
        y
        x0
        y0
        zp
        lambda
        lambda_vec 
        
        Nphoton
        DATA
        BACKGROUND
        simDATA
        simBACKGROUND
        MODEL
        vari
        gi
        oi
        ModelSignal
        SCOMval
        minlambdavec
        minlambdadiff
        minlambdaidx
        nSpectrumPoints
        nPointSpectralStruct
        intensarray
        deltalambda
        
        termA
        termB
        termC
        xxx
        
        calDATA
        calBACKGROUND
        
        logL
        llr
        minvarx0
        minvary0
        minvarzp
        minvarlambda               
        MLEstepxyzl
        MLEstepxyz
        xyzl
        iternum
        beadsz
        gauwidth
        PixelSize
        smoothingsigma
        gausigma    
        
        NA
        M
        ns
        ni
        DELTAt
        DELTAt_vec
        zd
        zdstar
        np
        na           
        K
        ALPHA
        
        rho
        theta
        Bstar
        THETAplate
        THETAZernike       
        
        filterwidthvec
        mincutoff
        maxcutoff
        filtersetpsfarray
        psfarray
        
        A
        b
        Aeq
        beq
        lb
        ub
        nonlcon
        options
        
        PSF
        spectralPSF
        ddx0PSF
        ddy0PSF
        ddzpPSF
        ddlambdaPSF
        d2dx02PSF
        d2dy02PSF
        d2dzp2PSF
        d2dlambda2PSF
    end
    methods
        function out = init(GibsonLaniPSF,GLMPP,PupilPlane)
            [xx,yy]=meshgrid(...
                linspace((GLMPP.PixelSize)*(-GLMPP.K/2),...
                         (GLMPP.PixelSize)*(GLMPP.K/2),GLMPP.K),...
                linspace((GLMPP.PixelSize)*(-GLMPP.K/2),...
                         (GLMPP.PixelSize)*(GLMPP.K/2),GLMPP.K));
            sizexy=size(xx); 
            numelrho=numel(PupilPlane.rho);
            GibsonLaniPSF.x=repmat(single(xx),1,1,numelrho);
            GibsonLaniPSF.y=repmat(single(yy),1,1,numelrho);
            GibsonLaniPSF.x0=single(zeros(sizexy(1),sizexy(2),numelrho));
            GibsonLaniPSF.y0=single(zeros(sizexy(1),sizexy(2),numelrho));
            GibsonLaniPSF.zp=single(zeros(sizexy(1),sizexy(2),numelrho));
            GibsonLaniPSF.lambda=single(zeros(sizexy(1),sizexy(2),numelrho));
            GibsonLaniPSF.lambda_vec=single([]);
            
            GibsonLaniPSF.Nphoton=single(0.0);
            GibsonLaniPSF.DATA=single(zeros(GLMPP.K));
            GibsonLaniPSF.BACKGROUND=single(zeros(GLMPP.K));
            GibsonLaniPSF.simDATA=single(zeros(GLMPP.K));
            GibsonLaniPSF.simBACKGROUND=single(zeros(GLMPP.K));
            GibsonLaniPSF.vari=single(0.0);
            GibsonLaniPSF.oi=single(0.0);
            GibsonLaniPSF.gi=single(0.0);
            GibsonLaniPSF.ModelSignal=single(zeros(GLMPP.K));
            GibsonLaniPSF.SCOMval=0.680;
            GibsonLaniPSF.minlambdavec=single.empty;
            GibsonLaniPSF.minlambdadiff=single.empty;
            GibsonLaniPSF.minlambdaidx=int16.empty;
            GibsonLaniPSF.deltalambda=0.002;
            GibsonLaniPSF.nSpectrumPoints=100;
            
            GibsonLaniPSF.termA=single(zeros(GLMPP.K));
            GibsonLaniPSF.termB=single(zeros(GLMPP.K));
            GibsonLaniPSF.termC=single(zeros(GLMPP.K));
            GibsonLaniPSF.xxx=single(zeros(GLMPP.K));
            
            GibsonLaniPSF.calDATA=[];
            GibsonLaniPSF.calBACKGROUND=[];
            
            GibsonLaniPSF.logL=single(0.0);
            GibsonLaniPSF.minvarx0=single(0.0);
            GibsonLaniPSF.minvary0=single(0.0);
            GibsonLaniPSF.minvarzp=single(0.0);
            GibsonLaniPSF.minvarlambda=single(0.0);
            GibsonLaniPSF.MLEstepxyzl=single(zeros(1,4));   
            GibsonLaniPSF.MLEstepxyz=single(zeros(1,3));
            GibsonLaniPSF.xyzl=single(zeros(1,4));
            GibsonLaniPSF.iternum=single(0.0);
            GibsonLaniPSF.beadsz=GLMPP.beadsz/2;
            GibsonLaniPSF.gauwidth=0.1;        
            GibsonLaniPSF.PixelSize=GLMPP.PixelSize;
            GibsonLaniPSF.gausigma=(GibsonLaniPSF.gauwidth/2)/...
                (GLMPP.PixelSize/GLMPP.M);
           
            GibsonLaniPSF.NA=repmat(GLMPP.NA*ones(sizexy),1,1,numelrho);
            GibsonLaniPSF.M=repmat(GLMPP.M*ones(sizexy),1,1,numelrho);
            GibsonLaniPSF.ns=repmat(GLMPP.ns*ones(sizexy),1,1,numelrho);
            GibsonLaniPSF.ni=repmat(GLMPP.ni*ones(sizexy),1,1,numelrho);
            GibsonLaniPSF.DELTAt=repmat(GLMPP.DELTAt*ones(sizexy),1,1,numelrho);
            GibsonLaniPSF.zd=repmat(GLMPP.zd*ones(sizexy),1,1,numelrho);
            GibsonLaniPSF.zdstar=repmat(GLMPP.zdstar*ones(sizexy),1,1,numelrho);
            GibsonLaniPSF.np=repmat(GLMPP.np*ones(sizexy),1,1,numelrho);
            GibsonLaniPSF.na=repmat(GLMPP.na*ones(sizexy),1,1,numelrho);
            GibsonLaniPSF.K=GLMPP.K;
            GibsonLaniPSF.ALPHA=single(0.0);
            GibsonLaniPSF.smoothingsigma=((GibsonLaniPSF.beadsz)/(...
            GibsonLaniPSF.PixelSize(1)/GibsonLaniPSF.M(1,1,1)));
        
            GibsonLaniPSF.rho=ones(sizexy(1),sizexy(2),numelrho);
            GibsonLaniPSF.theta=ones(sizexy(1),sizexy(2),numelrho);
            GibsonLaniPSF.Bstar=ones(sizexy(1),sizexy(2),numelrho);
            GibsonLaniPSF.THETAplate=ones(sizexy(1),sizexy(2),numelrho);
            GibsonLaniPSF.THETAZernike=ones(sizexy(1),sizexy(2),numelrho);
            for ii=1:numelrho
                GibsonLaniPSF.rho(:,:,ii)=GibsonLaniPSF.rho(:,:,ii)*PupilPlane.rho(ii);
                GibsonLaniPSF.theta(:,:,ii)=GibsonLaniPSF.theta(:,:,ii)*PupilPlane.theta(ii);
                GibsonLaniPSF.Bstar(:,:,ii)=GibsonLaniPSF.Bstar(:,:,ii)*PupilPlane.Bstar(ii);
                GibsonLaniPSF.THETAplate(:,:,ii)=GibsonLaniPSF.THETAplate(:,:,ii)*PupilPlane.THETAplate(ii);
                GibsonLaniPSF.THETAZernike(:,:,ii)=GibsonLaniPSF.THETAZernike(:,:,ii)*PupilPlane.THETAZernike(ii);
            end
            
            GibsonLaniPSF.filterwidthvec=ones(1,10);
            GibsonLaniPSF.mincutoff=0.400;
            GibsonLaniPSF.maxcutoff=0.850;
            GibsonLaniPSF.filtersetpsfarray=[];
            
            GibsonLaniPSF.A=[];
            GibsonLaniPSF.b=[];
            GibsonLaniPSF.Aeq=[];
            GibsonLaniPSF.beq=[];
            GibsonLaniPSF.lb=[-1,-1,-2,0.5];
            GibsonLaniPSF.ub=[1,1,2,0.8];
            GibsonLaniPSF.nonlcon=[];
            GibsonLaniPSF.options=optimoptions('fmincon','Algorithm','sqp',...
            'OptimalityTolerance',1e-15,...
            'StepTolerance',1e-15,...
            'FunctionTolerance',1e-15,...
            'MaxFunctionEvaluations',10000*numel(GibsonLaniPSF.ub),...
            'Display','off');
            
            GibsonLaniPSF.PSF=zeros(size(single(xx)));
            GibsonLaniPSF.ddx0PSF=zeros(size(single(xx)));
            GibsonLaniPSF.ddy0PSF=zeros(size(single(xx)));
            GibsonLaniPSF.ddzpPSF=zeros(size(single(xx)));
            GibsonLaniPSF.ddlambdaPSF=zeros(size(single(xx)));
            GibsonLaniPSF.d2dx02PSF=zeros(size(single(xx)));
            GibsonLaniPSF.d2dy02PSF=zeros(size(single(xx)));
            GibsonLaniPSF.d2dzp2PSF=zeros(size(single(xx)));
            GibsonLaniPSF.d2dlambda2PSF=zeros(size(single(xx)));
            
            out = GibsonLaniPSF;
        end
        function out = updatePupilPlane(GibsonLaniPSF,PupilPlane)
            for ii=1:numel(PupilPlane.rho)
                GibsonLaniPSF.rho(:,:,ii)=PupilPlane.rho(ii);
                GibsonLaniPSF.theta(:,:,ii)=PupilPlane.theta(ii);
                GibsonLaniPSF.Bstar(:,:,ii)=PupilPlane.Bstar(ii);
                GibsonLaniPSF.THETAplate(:,:,ii)=PupilPlane.THETAplate(ii);
                GibsonLaniPSF.THETAZernike(:,:,ii)=PupilPlane.THETAZernike(ii);
            end
            
            out = GibsonLaniPSF;
        end
        function out = loglikelihood(GibsonLaniPSF, DATAin,...
                BACKGROUNDin, x0in, y0in, zpin, lambdain)
            GibsonLaniPSF.DATA=single(DATAin);
            GibsonLaniPSF.BACKGROUND=single(BACKGROUNDin);
            GibsonLaniPSF.Nphoton=sum(sum(GibsonLaniPSF.DATA-GibsonLaniPSF.BACKGROUND));
            
            GibsonLaniPSF=GibsonLaniPSF.intens(x0in, y0in, zpin,...
                lambdain);
            
            GibsonLaniPSF.ModelSignal=GibsonLaniPSF.Nphoton*GibsonLaniPSF.PSF+GibsonLaniPSF.BACKGROUND;
            
            GibsonLaniPSF.logL=sum(sum(...
                GibsonLaniPSF.DATA.*log(abs(GibsonLaniPSF.ModelSignal))-...
                (GibsonLaniPSF.ModelSignal)-log(abs(GibsonLaniPSF.DATA))));
   
            out = GibsonLaniPSF;
        end
        function out = loglikelihoodratio(GibsonLaniPSF, DATAin,...
                BACKGROUNDin, variin, giin, oiin, x0in, y0in, zpin, lambdain)
            
            GibsonLaniPSF.vari=single(variin);
            GibsonLaniPSF.gi=single(giin);
            GibsonLaniPSF.oi=single(oiin);
            
            GibsonLaniPSF.DATA=single(DATAin);
            GibsonLaniPSF.BACKGROUND=single(BACKGROUNDin); % BACKGROUNDin and DATAin are 
            %taken to not be corrected for gain and offset. DATA and
            %BACKGROUND are corrected for gain and offset and represent
            %photon values.     
            GibsonLaniPSF.DATA=(GibsonLaniPSF.DATA-GibsonLaniPSF.oi)./GibsonLaniPSF.gi;
            
            GibsonLaniPSF.Nphoton=sum(sum( GibsonLaniPSF.DATA - GibsonLaniPSF.BACKGROUND ));
            
            GibsonLaniPSF=GibsonLaniPSF.intens(x0in, y0in, zpin,...
                lambdain);
            
            GibsonLaniPSF.ModelSignal=GibsonLaniPSF.Nphoton*GibsonLaniPSF.PSF...
                +GibsonLaniPSF.BACKGROUND;
            
            GibsonLaniPSF.termA=GibsonLaniPSF.vari./(GibsonLaniPSF.gi.^2);         
            GibsonLaniPSF.xxx=GibsonLaniPSF.DATA+GibsonLaniPSF.termA;
                        
            GibsonLaniPSF.llr=-2*sum(sum(...
                -(GibsonLaniPSF.ModelSignal)+...
                GibsonLaniPSF.DATA.*log(abs(GibsonLaniPSF.ModelSignal))+...
                GibsonLaniPSF.DATA-...
                GibsonLaniPSF.DATA.*log(abs(GibsonLaniPSF.DATA))));
   
            out = GibsonLaniPSF;
        end
        function out = llsCMOS(GibsonLaniPSF, DATAin,...
                BACKGROUNDin, variin, giin, oiin, x0in, y0in, zpin, lambdain)
            
            GibsonLaniPSF.vari=single(variin);
            GibsonLaniPSF.gi=single(giin);
            GibsonLaniPSF.oi=single(oiin);
            
            GibsonLaniPSF.DATA=single(DATAin);
            GibsonLaniPSF.BACKGROUND=single(BACKGROUNDin); % BACKGROUNDin and DATAin are 
            %taken to not be corrected for gain and offset. DATA and
            %BACKGROUND are corrected for gain and offset and represent
            %photon values.     
            GibsonLaniPSF.DATA=(GibsonLaniPSF.DATA-GibsonLaniPSF.oi)./GibsonLaniPSF.gi;
            
            GibsonLaniPSF.Nphoton=sum(sum( GibsonLaniPSF.DATA - GibsonLaniPSF.BACKGROUND ));
            
            GibsonLaniPSF=GibsonLaniPSF.intens(x0in, y0in, zpin,...
                lambdain);
            
            GibsonLaniPSF.ModelSignal=GibsonLaniPSF.Nphoton*GibsonLaniPSF.ALPHA*GibsonLaniPSF.PSF...
                +GibsonLaniPSF.BACKGROUND;
            
            GibsonLaniPSF.termA=GibsonLaniPSF.vari./(GibsonLaniPSF.gi.^2);         
            GibsonLaniPSF.xxx=GibsonLaniPSF.DATA+GibsonLaniPSF.termA;
            
            GibsonLaniPSF.logL=sum(sum(...
                (GibsonLaniPSF.ModelSignal+GibsonLaniPSF.termA)-...
                GibsonLaniPSF.xxx.*log(GibsonLaniPSF.ModelSignal+GibsonLaniPSF.termA)+...
                log(gamma(GibsonLaniPSF.xxx+1))...
                ));
   
            out = GibsonLaniPSF;
        end
        function out = llrsCMOS(GibsonLaniPSF, DATAin,...
                BACKGROUNDin, variin, giin, oiin, x0in, y0in, zpin, lambdain)
            
            GibsonLaniPSF.vari=single(variin);
            GibsonLaniPSF.gi=single(giin);
            GibsonLaniPSF.oi=single(oiin);
            
            GibsonLaniPSF.DATA=single(DATAin);
            GibsonLaniPSF.BACKGROUND=single(BACKGROUNDin); % BACKGROUNDin and DATAin are 
            %taken to not be corrected for gain and offset. DATA and
            %BACKGROUND are corrected for gain and offset and represent
            %photon values.     
            GibsonLaniPSF.DATA=(GibsonLaniPSF.DATA-GibsonLaniPSF.oi)./GibsonLaniPSF.gi;
            
            GibsonLaniPSF.Nphoton=sum(sum( GibsonLaniPSF.DATA - GibsonLaniPSF.BACKGROUND ));
            
            GibsonLaniPSF=GibsonLaniPSF.intens(x0in, y0in, zpin,...
                lambdain);
            
            GibsonLaniPSF.ModelSignal=GibsonLaniPSF.Nphoton*GibsonLaniPSF.PSF...
                +GibsonLaniPSF.BACKGROUND;
            
            GibsonLaniPSF.termA=GibsonLaniPSF.vari./(GibsonLaniPSF.gi.^2);         
            GibsonLaniPSF.xxx=GibsonLaniPSF.DATA+GibsonLaniPSF.termA;
                        
            GibsonLaniPSF.llr=-2*sum(sum(...
                -(GibsonLaniPSF.ModelSignal+GibsonLaniPSF.termA)+...
                GibsonLaniPSF.xxx.*log(abs(GibsonLaniPSF.ModelSignal+...
                GibsonLaniPSF.termA))+GibsonLaniPSF.xxx-...
                GibsonLaniPSF.xxx.*log(abs(GibsonLaniPSF.xxx))));
   
            out = GibsonLaniPSF;
        end
        function out = ObjFunvarblurxyzllblsCMOS(GibsonLaniPSF,ftval)
              
            ftval=single(ftval);

            GibsonLaniPSF=GibsonLaniPSF.varblur(ftval(1),...
                ftval(2),...
                ftval(3),...
                ftval(4));
                                
            GibsonLaniPSF.BACKGROUND=ftval(5)*ones(GibsonLaniPSF.K);
            GibsonLaniPSF.Nphoton=sum(sum(...
                GibsonLaniPSF.DATA - GibsonLaniPSF.BACKGROUND ));
            %Nphotontemp=sum(sum(...
                %GibsonLaniPSF.DATA - GibsonLaniPSF.BACKGROUND ))
            
            GibsonLaniPSF.MODEL=GibsonLaniPSF.Nphoton*GibsonLaniPSF.PSF+...
                GibsonLaniPSF.BACKGROUND;
            GibsonLaniPSF.termA=GibsonLaniPSF.vari./((GibsonLaniPSF.gi).^2);
            GibsonLaniPSF.xxx=GibsonLaniPSF.DATA+GibsonLaniPSF.termA;
                 
            out = double(sum(sum(...
            (GibsonLaniPSF.MODEL+GibsonLaniPSF.termA)-...
                GibsonLaniPSF.xxx.*log(...
                GibsonLaniPSF.MODEL+GibsonLaniPSF.termA)...
                )));
        end
        function out = fminsearchvarblurxyzllblsCMOS(GibsonLaniPSF, DATAin,...
                BACKGROUNDin, variin, giin, oiin, xyzlin, iternumin)
            
            GibsonLaniPSF.vari=single(variin);
            GibsonLaniPSF.gi=single(giin);
            GibsonLaniPSF.oi=single(oiin);
            ftval0=double([xyzlin;mean2(BACKGROUNDin)]);
            GibsonLaniPSF.iternum=iternumin;
            
            GibsonLaniPSF.DATA=single(DATAin);
            GibsonLaniPSF.BACKGROUND=single(BACKGROUNDin);%DATAin is ...
            %data not corrected for the pixel statistics. BACKGROUNDin is
            %taken in photon counts.
            GibsonLaniPSF.DATA=(GibsonLaniPSF.DATA-GibsonLaniPSF.oi)./GibsonLaniPSF.gi;
            
            fun=@(ftval)GibsonLaniPSF.ObjFunvarblurxyzllblsCMOS(ftval);
            
            %options=optimset('PlotFcns',@optimplotfval,...
            %    'MaxFunEvals',10000*numel(ftval0),'MaxIter',GibsonLaniPSF.iternum,...
            %    'TolFun',1e-4,'TolX',1e-4);
            
            GibsonLaniPSF.options=optimset('MaxFunEvals',10000*numel(ftval0),...
                'MaxIter',GibsonLaniPSF.iternum,...
                'TolFun',1e-10,'TolX',1e-10,'Display','off');
            
            ftval1=fminsearch(fun,ftval0,GibsonLaniPSF.options);
            ftval1=single(ftval1);
            GibsonLaniPSF.xyzl=ftval1(1:4);
            GibsonLaniPSF.BACKGROUND=ftval1(5)*single(ones(GibsonLaniPSF.K));
            
            out = GibsonLaniPSF;
        end        
        function out = ObjFunxyzlllsCMOS(GibsonLaniPSF,ftval)
              
            ftval=single(ftval);
            GibsonLaniPSF=GibsonLaniPSF.intens(ftval(1),...
                ftval(2),...
                ftval(3),...
                ftval(4));
            %GibsonLaniPSF=GibsonLaniPSF.bead(ftval(1),...
            %    ftval(2),...
            %    ftval(3),...
            %    ftval(4));
            GibsonLaniPSF.MODEL=GibsonLaniPSF.Nphoton*GibsonLaniPSF.PSF+...
                GibsonLaniPSF.BACKGROUND;
            GibsonLaniPSF.termA=GibsonLaniPSF.vari./((GibsonLaniPSF.gi).^2);
            GibsonLaniPSF.xxx=GibsonLaniPSF.DATA+GibsonLaniPSF.termA;
                 
            out = double(sum(sum(...
            (GibsonLaniPSF.MODEL+GibsonLaniPSF.termA)-...
                GibsonLaniPSF.xxx.*log(...
                GibsonLaniPSF.MODEL+GibsonLaniPSF.termA)...
                )));
        end
        function out = fminsearchxyzllsCMOS(GibsonLaniPSF, DATAin,...
                BACKGROUNDin, variin, giin, oiin, xyzlin, iternumin)
            
            GibsonLaniPSF.vari=single(variin);
            GibsonLaniPSF.gi=single(giin);
            GibsonLaniPSF.oi=single(oiin);
            ftval0=double(xyzlin);
            GibsonLaniPSF.iternum=iternumin;
            
            GibsonLaniPSF.DATA=single(DATAin);
            GibsonLaniPSF.BACKGROUND=single(BACKGROUNDin);%DATAin is ...
            %data not corrected for the pixel statistics. BACKGROUNDin is
            %taken in photon counts.
            GibsonLaniPSF.DATA=(GibsonLaniPSF.DATA-GibsonLaniPSF.oi)./GibsonLaniPSF.gi;
            GibsonLaniPSF.Nphoton=sum(sum( GibsonLaniPSF.DATA - GibsonLaniPSF.BACKGROUND ));
            
            fun=@(ftval)GibsonLaniPSF.ObjFunxyzlllsCMOS(ftval);
            
            %options=optimset('PlotFcns',@optimplotfval,...
            %    'MaxFunEvals',10000*numel(ftval0),'MaxIter',GibsonLaniPSF.iternum,...
            %    'TolFun',1e-4,'TolX',1e-4);
            
            GibsonLaniPSF.options=optimset('MaxFunEvals',10000*numel(ftval0),...
                'MaxIter',GibsonLaniPSF.iternum,...
                'TolFun',1e-10,'TolX',1e-10,'Display','off');
            
            ftval1=fminsearch(fun,ftval0,GibsonLaniPSF.options);
            ftval1=single(ftval1);
            GibsonLaniPSF.xyzl=ftval1;
            
            out = GibsonLaniPSF;
        end
        function out = fminconxyzllsCMOS(GibsonLaniPSF, DATAin,...
                BACKGROUNDin, variin, giin, oiin, xyzlin, iternumin)
            
            GibsonLaniPSF.vari=single(variin);
            GibsonLaniPSF.gi=single(giin);
            GibsonLaniPSF.oi=single(oiin);
            ftval0=double(xyzlin);
            GibsonLaniPSF.iternum=iternumin;
            
            GibsonLaniPSF.DATA=single(DATAin);
            GibsonLaniPSF.BACKGROUND=single(BACKGROUNDin);%DATAin is ...
            %data not corrected for the pixel statistics. BACKGROUNDin is
            %taken in photon counts.
            GibsonLaniPSF.DATA=(GibsonLaniPSF.DATA-GibsonLaniPSF.oi)./GibsonLaniPSF.gi;
            GibsonLaniPSF.Nphoton=sum(sum( GibsonLaniPSF.DATA - GibsonLaniPSF.BACKGROUND ));
            
            fun=@(ftval)GibsonLaniPSF.ObjFunxyzlllsCMOS(ftval);
            
            GibsonLaniPSF.options=optimoptions('fmincon','Algorithm','sqp',...
            'OptimalityTolerance',1e-15,...
            'StepTolerance',1e-15,...
            'FunctionTolerance',1e-15,...
            'MaxIterations',GibsonLaniPSF.iternum,...
            'MaxFunctionEvaluations',10000*numel(GibsonLaniPSF.ub),...
            'UseParallel',0,'Display','off');
            
            ftval1=fmincon(fun,ftval0,...
                GibsonLaniPSF.A,...
                GibsonLaniPSF.b,...
                GibsonLaniPSF.Aeq,...
                GibsonLaniPSF.beq,...
                GibsonLaniPSF.lb,...
                GibsonLaniPSF.ub,...
                GibsonLaniPSF.nonlcon,...
                GibsonLaniPSF.options);
            ftval1=single(ftval1);
            GibsonLaniPSF.xyzl=ftval1;
            
            out = GibsonLaniPSF;
        end
        function out = NRfitxyzlllsCMOS(GibsonLaniPSF, DATAin,...
                BACKGROUNDin, variin, giin, oiin, xyzlin, iternumin)
            GibsonLaniPSF.xyzl=single(xyzlin);
            GibsonLaniPSF.iternum=single(iternumin);
            for ii=1:GibsonLaniPSF.iternum
                GibsonLaniPSF=GibsonLaniPSF.NRStepxyzlllsCMOS(DATAin,...
                    BACKGROUNDin, variin, giin, oiin,...
                    GibsonLaniPSF.xyzl(1), GibsonLaniPSF.xyzl(2),...
                    GibsonLaniPSF.xyzl(3), GibsonLaniPSF.xyzl(4));    
                GibsonLaniPSF.xyzl=GibsonLaniPSF.xyzl-GibsonLaniPSF.MLEstepxyzl;
            end 
            out = GibsonLaniPSF;
        end
        function out = NRStepxyzlllsCMOS(GibsonLaniPSF, DATAin,...
                BACKGROUNDin, variin, giin, oiin, x0in, y0in, zpin, lambdain)
            
            GibsonLaniPSF.vari=single(variin);
            GibsonLaniPSF.gi=single(giin);
            GibsonLaniPSF.oi=single(oiin);
                     
            GibsonLaniPSF.DATA=single(DATAin);
            GibsonLaniPSF.BACKGROUND=single(BACKGROUNDin); % BACKGROUNDin and DATAin are 
            %taken to not be corrected for gain and offset. DATA and
            %BACKGROUND are corrected for gain and offset and represent
            %photon values.     
            GibsonLaniPSF.DATA=(GibsonLaniPSF.DATA-GibsonLaniPSF.oi)./GibsonLaniPSF.gi;
            GibsonLaniPSF.BACKGROUND=(GibsonLaniPSF.BACKGROUND-GibsonLaniPSF.oi)./GibsonLaniPSF.gi;
            GibsonLaniPSF.Nphoton=sum(sum( GibsonLaniPSF.DATA - GibsonLaniPSF.BACKGROUND ));
            
            GibsonLaniPSF=GibsonLaniPSF.intens(x0in, y0in, zpin,lambdain);
            GibsonLaniPSF=GibsonLaniPSF.ddx0(x0in, y0in, zpin,lambdain);
            GibsonLaniPSF=GibsonLaniPSF.d2dx02(x0in, y0in, zpin,lambdain);
            GibsonLaniPSF=GibsonLaniPSF.ddy0(x0in, y0in, zpin,lambdain);
            GibsonLaniPSF=GibsonLaniPSF.d2dy02(x0in, y0in, zpin,lambdain);
            GibsonLaniPSF=GibsonLaniPSF.ddzp(x0in, y0in, zpin,lambdain);
            GibsonLaniPSF=GibsonLaniPSF.d2dzp2(x0in, y0in, zpin,lambdain);
            GibsonLaniPSF=GibsonLaniPSF.ddlambda(x0in, y0in, zpin,lambdain);
            GibsonLaniPSF=GibsonLaniPSF.d2dlambda2(x0in, y0in, zpin,lambdain);
            
            GibsonLaniPSF.ALPHA=1/sum(sum(GibsonLaniPSF.PSF));
            
            GibsonLaniPSF.ModelSignal=GibsonLaniPSF.Nphoton*GibsonLaniPSF.ALPHA*GibsonLaniPSF.PSF...
                +GibsonLaniPSF.BACKGROUND;
            
            GibsonLaniPSF.termA=GibsonLaniPSF.vari./(GibsonLaniPSF.gi.^2);
            GibsonLaniPSF.xxx=GibsonLaniPSF.DATA+GibsonLaniPSF.termA;
            GibsonLaniPSF.termB=(1-GibsonLaniPSF.xxx./(GibsonLaniPSF.ModelSignal+GibsonLaniPSF.termA));
            GibsonLaniPSF.termC=(GibsonLaniPSF.xxx./(GibsonLaniPSF.ModelSignal+GibsonLaniPSF.termA));
            
        GibsonLaniPSF.MLEstepxyzl(1) = sum(sum(...
            GibsonLaniPSF.termB.*GibsonLaniPSF.Nphoton.*GibsonLaniPSF.ALPHA.*GibsonLaniPSF.ddx0PSF...
            ))...
            ./...
            sum(sum(...
            GibsonLaniPSF.termC.*(GibsonLaniPSF.Nphoton*GibsonLaniPSF.ALPHA*GibsonLaniPSF.ddx0PSF).^2+...
            GibsonLaniPSF.termB.*(GibsonLaniPSF.Nphoton*GibsonLaniPSF.ALPHA*GibsonLaniPSF.d2dx02PSF)...
            ));
        GibsonLaniPSF.MLEstepxyzl(2) = sum(sum(...
            GibsonLaniPSF.termB.*GibsonLaniPSF.Nphoton.*GibsonLaniPSF.ALPHA.*GibsonLaniPSF.ddy0PSF...
            ))...
            ./...
            sum(sum(...
            GibsonLaniPSF.termC.*(GibsonLaniPSF.Nphoton*GibsonLaniPSF.ALPHA*GibsonLaniPSF.ddy0PSF).^2+...
            GibsonLaniPSF.termB.*(GibsonLaniPSF.Nphoton*GibsonLaniPSF.ALPHA*GibsonLaniPSF.d2dy02PSF)...
            ));
        GibsonLaniPSF.MLEstepxyzl(3) = sum(sum(...
            GibsonLaniPSF.termB.*GibsonLaniPSF.Nphoton.*GibsonLaniPSF.ALPHA.*GibsonLaniPSF.ddzpPSF...
            ))...
            ./...
            sum(sum(...
            GibsonLaniPSF.termC.*(GibsonLaniPSF.Nphoton*GibsonLaniPSF.ALPHA*GibsonLaniPSF.ddzpPSF).^2+...
            GibsonLaniPSF.termB.*(GibsonLaniPSF.Nphoton*GibsonLaniPSF.ALPHA*GibsonLaniPSF.d2dzp2PSF)...
            ));
        GibsonLaniPSF.MLEstepxyzl(4) = sum(sum(...
            GibsonLaniPSF.termB.*GibsonLaniPSF.Nphoton.*GibsonLaniPSF.ALPHA.*GibsonLaniPSF.ddlambdaPSF...
            ))...
            ./...
            sum(sum(...
            GibsonLaniPSF.termC.*(GibsonLaniPSF.Nphoton*GibsonLaniPSF.ALPHA*GibsonLaniPSF.ddlambdaPSF).^2+...
            GibsonLaniPSF.termB.*(GibsonLaniPSF.Nphoton*GibsonLaniPSF.ALPHA*GibsonLaniPSF.d2dlambda2PSF)...
            ));
            
            out = GibsonLaniPSF;
        end
        function out = SimData(GibsonLaniPSF, Nphotonin, variin, giin, oiin,...
                x0in, y0in, zpin, lambdain)
            GibsonLaniPSF.Nphoton=single(Nphotonin);
            GibsonLaniPSF.vari=single(variin);
            GibsonLaniPSF.gi=single(giin);
            GibsonLaniPSF.oi=single(oiin);
            
            GibsonLaniPSF=...
                GibsonLaniPSF.intens(x0in, y0in, zpin, lambdain);
            
            GibsonLaniPSF.simBACKGROUND=...%simBACKGROUND is in terms of photons
                (max(max(GibsonLaniPSF.Nphoton*GibsonLaniPSF.PSF))/...
                single(10))*single(ones(size(GibsonLaniPSF.vari)));
            
            GibsonLaniPSF.simDATA=...
                poissrnd(GibsonLaniPSF.Nphoton*GibsonLaniPSF.PSF.*...
                GibsonLaniPSF.gi+GibsonLaniPSF.simBACKGROUND.*GibsonLaniPSF.gi)+...
                GibsonLaniPSF.oi;

            out = GibsonLaniPSF;
        end
        function out = intens(GibsonLaniPSF, x0in, y0in, zpin, lambdain)            
           
            GibsonLaniPSF.x0(:)=GibsonLaniPSF.M*single(x0in);
            
            GibsonLaniPSF.y0(:)=GibsonLaniPSF.M*single(y0in);
            
            GibsonLaniPSF.zp(:)=single(zpin);
            
            GibsonLaniPSF.lambda(:)=single(lambdain);
                     
            Integral = GibsonLaniPSFModel(...
                GibsonLaniPSF.x,...
                GibsonLaniPSF.y,...
                GibsonLaniPSF.x0,...
                GibsonLaniPSF.y0,...
                GibsonLaniPSF.zp,...
                GibsonLaniPSF.lambda,...
                GibsonLaniPSF.NA,...
                GibsonLaniPSF.M,...
                GibsonLaniPSF.ns,...
                GibsonLaniPSF.ni,...
                GibsonLaniPSF.DELTAt,...
                GibsonLaniPSF.zd,...
                GibsonLaniPSF.zdstar,...
                GibsonLaniPSF.np,...
                GibsonLaniPSF.na,...
                GibsonLaniPSF.rho,...
                GibsonLaniPSF.theta,...
                GibsonLaniPSF.Bstar,...
                GibsonLaniPSF.THETAplate,...
                GibsonLaniPSF.THETAZernike...
            );
        
        ModelPSF=Integral.*conj(Integral);      
        
        GibsonLaniPSF.PSF=ModelPSF./sum(sum(ModelPSF));
        
        GibsonLaniPSF.PSF(isnan(GibsonLaniPSF.PSF))=0;
        
        out = GibsonLaniPSF;
        end
        function out = intensstandard(GibsonLaniPSF, x0in, y0in, zpin, lambdain)            
           
            GibsonLaniPSF.x0(:)=GibsonLaniPSF.M*single(x0in);
            
            GibsonLaniPSF.y0(:)=GibsonLaniPSF.M*single(y0in);
            
            GibsonLaniPSF.zp(:)=single(zpin);
            
            GibsonLaniPSF.lambda(:)=single(lambdain);
                     
            Integral = GibsonLaniPSFModel(...
                GibsonLaniPSF.x,...
                GibsonLaniPSF.y,...
                GibsonLaniPSF.x0,...
                GibsonLaniPSF.y0,...
                GibsonLaniPSF.zp,...
                GibsonLaniPSF.lambda,...
                GibsonLaniPSF.NA,...
                GibsonLaniPSF.M,...
                GibsonLaniPSF.ns,...
                GibsonLaniPSF.ni,...
                GibsonLaniPSF.DELTAt,...
                GibsonLaniPSF.zd,...
                GibsonLaniPSF.zdstar,...
                GibsonLaniPSF.np,...
                GibsonLaniPSF.na,...
                GibsonLaniPSF.rho,...
                GibsonLaniPSF.theta,...
                GibsonLaniPSF.Bstar,...
                zeros(size(GibsonLaniPSF.THETAplate)),...
                GibsonLaniPSF.THETAZernike...
            );
        
        ModelPSF=Integral.*conj(Integral);      
        
        GibsonLaniPSF.PSF=ModelPSF./sum(sum(ModelPSF));
        
        GibsonLaniPSF.PSF(isnan(GibsonLaniPSF.PSF))=0;
        
        out = GibsonLaniPSF;
        end
        function out = bead(GibsonLaniPSF, x0in, y0in, zpin, lambdain)            
           
            GibsonLaniPSF.x0(:)=GibsonLaniPSF.M*single(x0in);
            
            GibsonLaniPSF.y0(:)=GibsonLaniPSF.M*single(y0in);
            
            GibsonLaniPSF.zp(:)=single(zpin);
            
            GibsonLaniPSF.lambda(:)=single(lambdain);
                     
            Integral = GibsonLaniPSFModel(...
                GibsonLaniPSF.x,...
                GibsonLaniPSF.y,...
                GibsonLaniPSF.x0,...
                GibsonLaniPSF.y0,...
                GibsonLaniPSF.zp,...
                GibsonLaniPSF.lambda,...
                GibsonLaniPSF.NA,...
                GibsonLaniPSF.M,...
                GibsonLaniPSF.ns,...
                GibsonLaniPSF.ni,...
                GibsonLaniPSF.DELTAt,...
                GibsonLaniPSF.zd,...
                GibsonLaniPSF.zdstar,...
                GibsonLaniPSF.np,...
                GibsonLaniPSF.na,...
                GibsonLaniPSF.rho,...
                GibsonLaniPSF.theta,...
                GibsonLaniPSF.Bstar,...
                GibsonLaniPSF.THETAplate,...
                GibsonLaniPSF.THETAZernike...
            );
        
        ModelPSF=imgaussfilt((Integral.*conj(Integral)),...
            GibsonLaniPSF.smoothingsigma);      
        
        GibsonLaniPSF.PSF=ModelPSF./sum(sum(ModelPSF));
        
        GibsonLaniPSF.PSF(isnan(GibsonLaniPSF.PSF))=0;
        
        out = GibsonLaniPSF;
        end
        function out = nPointSpectrum(GibsonLaniPSF, wavelengthin, spectrumin, filterin)
                        
            transmission=spectrumin.*filterin;
            % calulate the index of the element in the transmitted spectrum with a
            % value closest to the minimum lambda value. This block has to occur before
            % the next one so the delta lambda is scalled correctly (in microns) to
            % find the minimum lambda
            
            GibsonLaniPSF.SCOMval=SCOM(transmission,wavelengthin);
            GibsonLaniPSF.minlambdavec=(GibsonLaniPSF.SCOMval-...
                ((GibsonLaniPSF.nSpectrumPoints-1)/2)*GibsonLaniPSF.deltalambda).*...
                ones(numel(wavelengthin),1);
            GibsonLaniPSF.minlambdadiff=abs(GibsonLaniPSF.minlambdavec-wavelengthin);
            %abs(GibsonLaniPSF.minlambdavec-wavelengthin)
            %min(find(GibsonLaniPSF.minlambdadiff==min(GibsonLaniPSF.minlambdadiff)))
            GibsonLaniPSF.minlambdaidx=min(find(GibsonLaniPSF.minlambdadiff==min(GibsonLaniPSF.minlambdadiff)));

            % spectral increments are in single nanometeres. delta_lambda is input in microns, but a value of delta_lambda=1 corresponds to a step of one nanometer. delta lambda is converted to nm and rounded to the nearest ingeral nanometer.
            dl=round(1000*GibsonLaniPSF.deltalambda);

            % select the n points
            nPointWavelength=zeros(GibsonLaniPSF.nSpectrumPoints,1);
            nPointTransmission=zeros(GibsonLaniPSF.nSpectrumPoints,1);
            for ii=1:GibsonLaniPSF.nSpectrumPoints

                nPointWavelength(ii)=wavelengthin(GibsonLaniPSF.minlambdaidx+(ii-1)*dl);
                nPointTransmission(ii)=transmission(GibsonLaniPSF.minlambdaidx+(ii-1)*dl);
            end
            GibsonLaniPSF.nPointSpectralStruct=struct('wavelength',nPointWavelength,...
                                                      'transmission',nPointTransmission);
                                                  
            out = GibsonLaniPSF;
        end
        function out = spectralintens(GibsonLaniPSF, x0in, y0in, zpin, wavelengthsin, spectrain, filtersin)
            wavelengthsin=reshape(wavelengthsin,[numel(wavelengthsin),1]);
            spectrain=reshape(spectrain,[numel(spectrain),1]);
            filtersin=reshape(filtersin,[numel(filtersin),1]);
            
            GibsonLaniPSF=GibsonLaniPSF.nPointSpectrum(single(wavelengthsin), single(spectrain), single(filtersin));
            GibsonLaniPSF.intensarray=zeros(size(GibsonLaniPSF.x,1),size(GibsonLaniPSF.x,2));
            for ii=1:numel(GibsonLaniPSF.nPointSpectralStruct.wavelength)
                GibsonLaniPSF = GibsonLaniPSF.intens(x0in, y0in, zpin,...
                    GibsonLaniPSF.nPointSpectralStruct.wavelength(ii)); 
                GibsonLaniPSF.intensarray(:,:,ii) = GibsonLaniPSF.nPointSpectralStruct.transmission(ii).*...
                    (GibsonLaniPSF.PSF./sum(sum(GibsonLaniPSF.PSF)));
            end
            GibsonLaniPSF.spectralPSF = sum(GibsonLaniPSF.intensarray,3);
            GibsonLaniPSF.ALPHA = sum(sum(GibsonLaniPSF.spectralPSF));
            GibsonLaniPSF.spectralPSF = GibsonLaniPSF.spectralPSF./...
                GibsonLaniPSF.ALPHA;
            
            GibsonLaniPSF.spectralPSF(isnan(GibsonLaniPSF.spectralPSF))=0;
            
            out = GibsonLaniPSF;
        end
        function out = spectralintensstandard(GibsonLaniPSF, x0in, y0in, zpin, wavelengthsin, spectrain, filtersin)
            wavelengthsin=reshape(wavelengthsin,[numel(wavelengthsin),1]);
            spectrain=reshape(spectrain,[numel(spectrain),1]);
            filtersin=reshape(filtersin,[numel(filtersin),1]);
            
            GibsonLaniPSF=GibsonLaniPSF.nPointSpectrum(single(wavelengthsin), single(spectrain), single(filtersin));
            GibsonLaniPSF.intensarray=zeros(size(GibsonLaniPSF.x,1),size(GibsonLaniPSF.x,2));
            for ii=1:numel(GibsonLaniPSF.nPointSpectralStruct.wavelength)
                GibsonLaniPSF = GibsonLaniPSF.intensstandard(x0in, y0in, zpin,...
                    GibsonLaniPSF.nPointSpectralStruct.wavelength(ii)); 
                GibsonLaniPSF.intensarray(:,:,ii) = GibsonLaniPSF.nPointSpectralStruct.transmission(ii).*...
                    (GibsonLaniPSF.PSF./sum(sum(GibsonLaniPSF.PSF)));
            end
            GibsonLaniPSF.spectralPSF = sum(GibsonLaniPSF.intensarray,3);
            GibsonLaniPSF.ALPHA = sum(sum(GibsonLaniPSF.spectralPSF));
            GibsonLaniPSF.spectralPSF = GibsonLaniPSF.spectralPSF./...
                GibsonLaniPSF.ALPHA;
            
            GibsonLaniPSF.spectralPSF(isnan(GibsonLaniPSF.spectralPSF))=0;
            
            out = GibsonLaniPSF;
        end
        function out = fitlersetstandard(GibsonLaniPSF,filterwidthvecin,...
                    mincutoffin, maxcutoffin, x0in, y0in, zpin, ...
                    SpectralStructurein)
                
                GibsonLaniPSF.filtersetpsfarray=[];
                
                GibsonLaniPSF.filterwidthvec = single(filterwidthvecin);
                GibsonLaniPSF.mincutoff = single(mincutoffin);
                GibsonLaniPSF.maxcutoff = single(maxcutoffin);
                
                FilterSet = FilterSetClass;
                FilterSet = FilterSet.init(SpectralStructurein,...
                filterwidthvecin, mincutoffin, maxcutoffin);
                FilterSet = FilterSet.create;
                
                for jj = 1:numel(FilterSet.fields)
                    GibsonLaniPSF.psfarray=[];
                    for ii = 1:numel(FilterSet.SpectralStructure)
                        GibsonLaniPSF=GibsonLaniPSF.spectralintensstandard(...
                            x0in,...
                            y0in,...
                            zpin,...
                            FilterSet.SpectralStructure(ii).(FilterSet.fields{jj}).Wavelength,...
                            FilterSet.SpectralStructure(ii).(FilterSet.fields{jj}).Spectrum,...
                            FilterSet.SpectralStructure(ii).(FilterSet.fields{jj}).Filter);
                        GibsonLaniPSF.psfarray=cat(...
                            2, GibsonLaniPSF.psfarray,...
                            FilterSet.SpectralStructure(ii).(FilterSet.fields{jj}).photonfraction*...
                            GibsonLaniPSF.spectralPSF); 
                    end
                    GibsonLaniPSF.filtersetpsfarray=cat(...
                        3,GibsonLaniPSF.filtersetpsfarray,GibsonLaniPSF.psfarray);
                end

            out = GibsonLaniPSF;
        end
        function out = varblur(GibsonLaniPSF, x0in, y0in, zpin,...
                lambdain)            
           
            GibsonLaniPSF.x0(:)=GibsonLaniPSF.M*single(x0in);
            
            GibsonLaniPSF.y0(:)=GibsonLaniPSF.M*single(y0in);
            
            GibsonLaniPSF.zp(:)=single(zpin);
            
            GibsonLaniPSF.lambda(:)=single(lambdain);
                     
            Integral = GibsonLaniPSFModel(...
                GibsonLaniPSF.x,...
                GibsonLaniPSF.y,...
                GibsonLaniPSF.x0,...
                GibsonLaniPSF.y0,...
                GibsonLaniPSF.zp,...
                GibsonLaniPSF.lambda,...
                GibsonLaniPSF.NA,...
                GibsonLaniPSF.M,...
                GibsonLaniPSF.ns,...
                GibsonLaniPSF.ni,...
                GibsonLaniPSF.DELTAt,...
                GibsonLaniPSF.zd,...
                GibsonLaniPSF.zdstar,...
                GibsonLaniPSF.np,...
                GibsonLaniPSF.na,...
                GibsonLaniPSF.rho,...
                GibsonLaniPSF.theta,...
                GibsonLaniPSF.Bstar,...
                GibsonLaniPSF.THETAplate,...
                GibsonLaniPSF.THETAZernike...
            );
        
        ModelPSF=imgaussfilt((Integral.*conj(Integral)),...
            GibsonLaniPSF.gausigma);      
        
        GibsonLaniPSF.PSF=ModelPSF./sum(sum(ModelPSF));
        
        GibsonLaniPSF.spectralPSF(isnan(GibsonLaniPSF.spectralPSF))=0;
        
        out = GibsonLaniPSF;
        end   
        function out = ddx0(GibsonLaniPSF, x0in, y0in, zpin, lambdain)            
            GibsonLaniPSF.x0(:)=GibsonLaniPSF.M*single(x0in);
            
            GibsonLaniPSF.y0(:)=GibsonLaniPSF.M*single(y0in);
            
            GibsonLaniPSF.zp(:)=single(zpin);
            
            GibsonLaniPSF.lambda(:)=single(lambdain);
            
            Integral = GibsonLaniPSFModel(...
                GibsonLaniPSF.x,...
                GibsonLaniPSF.y,...
                GibsonLaniPSF.x0,...
                GibsonLaniPSF.y0,...
                GibsonLaniPSF.zp,...
                GibsonLaniPSF.lambda,...
                GibsonLaniPSF.NA,...
                GibsonLaniPSF.M,...
                GibsonLaniPSF.ns,...
                GibsonLaniPSF.ni,...
                GibsonLaniPSF.DELTAt,...
                GibsonLaniPSF.zd,...
                GibsonLaniPSF.zdstar,...
                GibsonLaniPSF.np,...
                GibsonLaniPSF.na,...
                GibsonLaniPSF.rho,...
                GibsonLaniPSF.theta,...
                GibsonLaniPSF.Bstar,...
                GibsonLaniPSF.THETAplate,...
                GibsonLaniPSF.THETAZernike...
            );
            
            ddx0Integral = GibsonLaniPSFModelddx0(...
                GibsonLaniPSF.x,...
                GibsonLaniPSF.y,...
                GibsonLaniPSF.x0,...
                GibsonLaniPSF.y0,...
                GibsonLaniPSF.zp,...
                GibsonLaniPSF.lambda,...
                GibsonLaniPSF.NA,...
                GibsonLaniPSF.M,...
                GibsonLaniPSF.ns,...
                GibsonLaniPSF.ni,...
                GibsonLaniPSF.DELTAt,...
                GibsonLaniPSF.zd,...
                GibsonLaniPSF.zdstar,...
                GibsonLaniPSF.np,...
                GibsonLaniPSF.na,...
                GibsonLaniPSF.rho,...
                GibsonLaniPSF.theta,...
                GibsonLaniPSF.Bstar,...
                GibsonLaniPSF.THETAplate,...
                GibsonLaniPSF.THETAZernike...
            );
        
        ModelPSF=conj(Integral).*Integral;
               
        GibsonLaniPSF.ddx0PSF=(conj(ddx0Integral).*Integral+...
            conj(Integral).*ddx0Integral)./sum(sum(ModelPSF)); 
                         
        out = GibsonLaniPSF;
        end
        function out = ddy0(GibsonLaniPSF, x0in, y0in, zpin, lambdain)            
            GibsonLaniPSF.x0(:)=GibsonLaniPSF.M*single(x0in);
            
            GibsonLaniPSF.y0(:)=GibsonLaniPSF.M*single(y0in);
            
            GibsonLaniPSF.zp(:)=single(zpin);
            
            GibsonLaniPSF.lambda(:)=single(lambdain);
    
            Integral = GibsonLaniPSFModel(...
                GibsonLaniPSF.x,...
                GibsonLaniPSF.y,...
                GibsonLaniPSF.x0,...
                GibsonLaniPSF.y0,...
                GibsonLaniPSF.zp,...
                GibsonLaniPSF.lambda,...
                GibsonLaniPSF.NA,...
                GibsonLaniPSF.M,...
                GibsonLaniPSF.ns,...
                GibsonLaniPSF.ni,...
                GibsonLaniPSF.DELTAt,...
                GibsonLaniPSF.zd,...
                GibsonLaniPSF.zdstar,...
                GibsonLaniPSF.np,...
                GibsonLaniPSF.na,...
                GibsonLaniPSF.rho,...
                GibsonLaniPSF.theta,...
                GibsonLaniPSF.Bstar,...
                GibsonLaniPSF.THETAplate,...
                GibsonLaniPSF.THETAZernike...
            );
            
            ddy0Integral = GibsonLaniPSFModelddy0(...
                GibsonLaniPSF.x,...
                GibsonLaniPSF.y,...
                GibsonLaniPSF.x0,...
                GibsonLaniPSF.y0,...
                GibsonLaniPSF.zp,...
                GibsonLaniPSF.lambda,...
                GibsonLaniPSF.NA,...
                GibsonLaniPSF.M,...
                GibsonLaniPSF.ns,...
                GibsonLaniPSF.ni,...
                GibsonLaniPSF.DELTAt,...
                GibsonLaniPSF.zd,...
                GibsonLaniPSF.zdstar,...
                GibsonLaniPSF.np,...
                GibsonLaniPSF.na,...
                GibsonLaniPSF.rho,...
                GibsonLaniPSF.theta,...
                GibsonLaniPSF.Bstar,...
                GibsonLaniPSF.THETAplate,...
                GibsonLaniPSF.THETAZernike...
            );
        
        ModelPSF=conj(Integral).*Integral;
              
        GibsonLaniPSF.ddy0PSF=(conj(ddy0Integral).*Integral+...
            conj(Integral).*ddy0Integral)./sum(sum(ModelPSF)); 
                 
        out = GibsonLaniPSF;
        end
        function out = ddzp(GibsonLaniPSF, x0in, y0in, zpin, lambdain)            
            GibsonLaniPSF.x0(:)=GibsonLaniPSF.M*single(x0in);
            
            GibsonLaniPSF.y0(:)=GibsonLaniPSF.M*single(y0in);
            
            GibsonLaniPSF.zp(:)=single(zpin);
            
            GibsonLaniPSF.lambda(:)=single(lambdain);
                     
            Integral = GibsonLaniPSFModel(...
                GibsonLaniPSF.x,...
                GibsonLaniPSF.y,...
                GibsonLaniPSF.x0,...
                GibsonLaniPSF.y0,...
                GibsonLaniPSF.zp,...
                GibsonLaniPSF.lambda,...
                GibsonLaniPSF.NA,...
                GibsonLaniPSF.M,...
                GibsonLaniPSF.ns,...
                GibsonLaniPSF.ni,...
                GibsonLaniPSF.DELTAt,...
                GibsonLaniPSF.zd,...
                GibsonLaniPSF.zdstar,...
                GibsonLaniPSF.np,...
                GibsonLaniPSF.na,...
                GibsonLaniPSF.rho,...
                GibsonLaniPSF.theta,...
                GibsonLaniPSF.Bstar,...
                GibsonLaniPSF.THETAplate,...
                GibsonLaniPSF.THETAZernike...
            );
            
            ddzpIntegral = GibsonLaniPSFModelddzp(...
                GibsonLaniPSF.x,...
                GibsonLaniPSF.y,...
                GibsonLaniPSF.x0,...
                GibsonLaniPSF.y0,...
                GibsonLaniPSF.zp,...
                GibsonLaniPSF.lambda,...
                GibsonLaniPSF.NA,...
                GibsonLaniPSF.M,...
                GibsonLaniPSF.ns,...
                GibsonLaniPSF.ni,...
                GibsonLaniPSF.DELTAt,...
                GibsonLaniPSF.zd,...
                GibsonLaniPSF.zdstar,...
                GibsonLaniPSF.np,...
                GibsonLaniPSF.na,...
                GibsonLaniPSF.rho,...
                GibsonLaniPSF.theta,...
                GibsonLaniPSF.Bstar,...
                GibsonLaniPSF.THETAplate,...
                GibsonLaniPSF.THETAZernike...
            );
        
        ModelPSF=conj(Integral).*Integral;  
               
        GibsonLaniPSF.ddzpPSF=(conj(ddzpIntegral).*Integral+...
            conj(Integral).*ddzpIntegral)./sum(sum(ModelPSF));         

        out = GibsonLaniPSF;
        end
        function out = ddlambda(GibsonLaniPSF, x0in, y0in, zpin, lambdain)            
            GibsonLaniPSF.x0(:)=GibsonLaniPSF.M*single(x0in);
            
            GibsonLaniPSF.y0(:)=GibsonLaniPSF.M*single(y0in);
            
            GibsonLaniPSF.zp(:)=single(zpin);
            
            GibsonLaniPSF.lambda(:)=single(lambdain);
                     
            Integral = GibsonLaniPSFModel(...
                GibsonLaniPSF.x,...
                GibsonLaniPSF.y,...
                GibsonLaniPSF.x0,...
                GibsonLaniPSF.y0,...
                GibsonLaniPSF.zp,...
                GibsonLaniPSF.lambda,...
                GibsonLaniPSF.NA,...
                GibsonLaniPSF.M,...
                GibsonLaniPSF.ns,...
                GibsonLaniPSF.ni,...
                GibsonLaniPSF.DELTAt,...
                GibsonLaniPSF.zd,...
                GibsonLaniPSF.zdstar,...
                GibsonLaniPSF.np,...
                GibsonLaniPSF.na,...
                GibsonLaniPSF.rho,...
                GibsonLaniPSF.theta,...
                GibsonLaniPSF.Bstar,...
                GibsonLaniPSF.THETAplate,...
                GibsonLaniPSF.THETAZernike...
            );
            
            ddlambdaIntegral = GibsonLaniPSFModelddlambda(...
                GibsonLaniPSF.x,...
                GibsonLaniPSF.y,...
                GibsonLaniPSF.x0,...
                GibsonLaniPSF.y0,...
                GibsonLaniPSF.zp,...
                GibsonLaniPSF.lambda,...
                GibsonLaniPSF.NA,...
                GibsonLaniPSF.M,...
                GibsonLaniPSF.ns,...
                GibsonLaniPSF.ni,...
                GibsonLaniPSF.DELTAt,...
                GibsonLaniPSF.zd,...
                GibsonLaniPSF.zdstar,...
                GibsonLaniPSF.np,...
                GibsonLaniPSF.na,...
                GibsonLaniPSF.rho,...
                GibsonLaniPSF.theta,...
                GibsonLaniPSF.Bstar,...
                GibsonLaniPSF.THETAplate,...
                GibsonLaniPSF.THETAZernike...
            );
        
        ModelPSF=conj(Integral).*Integral; 
        
        GibsonLaniPSF.ddlambdaPSF=(conj(ddlambdaIntegral).*Integral+...
            conj(Integral).*ddlambdaIntegral)./sum(sum(ModelPSF)); 
                  
        out = GibsonLaniPSF;
        end
        function out = d2dx02(GibsonLaniPSF, x0in, y0in, zpin, lambdain)            
            GibsonLaniPSF.x0(:)=GibsonLaniPSF.M*single(x0in);
            
            GibsonLaniPSF.y0(:)=GibsonLaniPSF.M*single(y0in);
            
            GibsonLaniPSF.zp(:)=single(zpin);
            
            GibsonLaniPSF.lambda(:)=single(lambdain);
            
            Integral = GibsonLaniPSFModel(...
                GibsonLaniPSF.x,...
                GibsonLaniPSF.y,...
                GibsonLaniPSF.x0,...
                GibsonLaniPSF.y0,...
                GibsonLaniPSF.zp,...
                GibsonLaniPSF.lambda,...
                GibsonLaniPSF.NA,...
                GibsonLaniPSF.M,...
                GibsonLaniPSF.ns,...
                GibsonLaniPSF.ni,...
                GibsonLaniPSF.DELTAt,...
                GibsonLaniPSF.zd,...
                GibsonLaniPSF.zdstar,...
                GibsonLaniPSF.np,...
                GibsonLaniPSF.na,...
                GibsonLaniPSF.rho,...
                GibsonLaniPSF.theta,...
                GibsonLaniPSF.Bstar,...
                GibsonLaniPSF.THETAplate,...
                GibsonLaniPSF.THETAZernike...
            );
            
            ddx0Integral = GibsonLaniPSFModelddx0(...
                GibsonLaniPSF.x,...
                GibsonLaniPSF.y,...
                GibsonLaniPSF.x0,...
                GibsonLaniPSF.y0,...
                GibsonLaniPSF.zp,...
                GibsonLaniPSF.lambda,...
                GibsonLaniPSF.NA,...
                GibsonLaniPSF.M,...
                GibsonLaniPSF.ns,...
                GibsonLaniPSF.ni,...
                GibsonLaniPSF.DELTAt,...
                GibsonLaniPSF.zd,...
                GibsonLaniPSF.zdstar,...
                GibsonLaniPSF.np,...
                GibsonLaniPSF.na,...
                GibsonLaniPSF.rho,...
                GibsonLaniPSF.theta,...
                GibsonLaniPSF.Bstar,...
                GibsonLaniPSF.THETAplate,...
                GibsonLaniPSF.THETAZernike...
            );
        
            d2dx02Integral = GibsonLaniPSFModeld2dx02(...
                GibsonLaniPSF.x,...
                GibsonLaniPSF.y,...
                GibsonLaniPSF.x0,...
                GibsonLaniPSF.y0,...
                GibsonLaniPSF.zp,...
                GibsonLaniPSF.lambda,...
                GibsonLaniPSF.NA,...
                GibsonLaniPSF.M,...
                GibsonLaniPSF.ns,...
                GibsonLaniPSF.ni,...
                GibsonLaniPSF.DELTAt,...
                GibsonLaniPSF.zd,...
                GibsonLaniPSF.zdstar,...
                GibsonLaniPSF.np,...
                GibsonLaniPSF.na,...
                GibsonLaniPSF.rho,...
                GibsonLaniPSF.theta,...
                GibsonLaniPSF.Bstar,...
                GibsonLaniPSF.THETAplate,...
                GibsonLaniPSF.THETAZernike...
            );
        
        ModelPSF=conj(Integral).*Integral;
        
        GibsonLaniPSF.d2dx02PSF=(conj(d2dx02Integral).*Integral+...
            2*conj(ddx0Integral).*ddx0Integral+...
            conj(Integral).*d2dx02Integral)./sum(sum(ModelPSF));                  
        
        out = GibsonLaniPSF;
        end
        function out = d2dy02(GibsonLaniPSF, x0in, y0in, zpin, lambdain)            
            GibsonLaniPSF.x0(:)=GibsonLaniPSF.M*single(x0in);
            
            GibsonLaniPSF.y0(:)=GibsonLaniPSF.M*single(y0in);
            
            GibsonLaniPSF.zp(:)=single(zpin);
            
            GibsonLaniPSF.lambda(:)=single(lambdain);
            
            Integral = GibsonLaniPSFModel(...
                GibsonLaniPSF.x,...
                GibsonLaniPSF.y,...
                GibsonLaniPSF.x0,...
                GibsonLaniPSF.y0,...
                GibsonLaniPSF.zp,...
                GibsonLaniPSF.lambda,...
                GibsonLaniPSF.NA,...
                GibsonLaniPSF.M,...
                GibsonLaniPSF.ns,...
                GibsonLaniPSF.ni,...
                GibsonLaniPSF.DELTAt,...
                GibsonLaniPSF.zd,...
                GibsonLaniPSF.zdstar,...
                GibsonLaniPSF.np,...
                GibsonLaniPSF.na,...
                GibsonLaniPSF.rho,...
                GibsonLaniPSF.theta,...
                GibsonLaniPSF.Bstar,...
                GibsonLaniPSF.THETAplate,...
                GibsonLaniPSF.THETAZernike...
            );
            
            ddy0Integral = GibsonLaniPSFModelddy0(...
                GibsonLaniPSF.x,...
                GibsonLaniPSF.y,...
                GibsonLaniPSF.x0,...
                GibsonLaniPSF.y0,...
                GibsonLaniPSF.zp,...
                GibsonLaniPSF.lambda,...
                GibsonLaniPSF.NA,...
                GibsonLaniPSF.M,...
                GibsonLaniPSF.ns,...
                GibsonLaniPSF.ni,...
                GibsonLaniPSF.DELTAt,...
                GibsonLaniPSF.zd,...
                GibsonLaniPSF.zdstar,...
                GibsonLaniPSF.np,...
                GibsonLaniPSF.na,...
                GibsonLaniPSF.rho,...
                GibsonLaniPSF.theta,...
                GibsonLaniPSF.Bstar,...
                GibsonLaniPSF.THETAplate,...
                GibsonLaniPSF.THETAZernike...
            );
        
            d2dy02Integral = GibsonLaniPSFModeld2dy02(...
                GibsonLaniPSF.x,...
                GibsonLaniPSF.y,...
                GibsonLaniPSF.x0,...
                GibsonLaniPSF.y0,...
                GibsonLaniPSF.zp,...
                GibsonLaniPSF.lambda,...
                GibsonLaniPSF.NA,...
                GibsonLaniPSF.M,...
                GibsonLaniPSF.ns,...
                GibsonLaniPSF.ni,...
                GibsonLaniPSF.DELTAt,...
                GibsonLaniPSF.zd,...
                GibsonLaniPSF.zdstar,...
                GibsonLaniPSF.np,...
                GibsonLaniPSF.na,...
                GibsonLaniPSF.rho,...
                GibsonLaniPSF.theta,...
                GibsonLaniPSF.Bstar,...
                GibsonLaniPSF.THETAplate,...
                GibsonLaniPSF.THETAZernike...
            );
        
        ModelPSF=conj(Integral).*Integral;
        
        GibsonLaniPSF.d2dy02PSF=(conj(d2dy02Integral).*Integral+...
            2*conj(ddy0Integral).*ddy0Integral+...
            conj(Integral).*d2dy02Integral)./sum(sum(ModelPSF));                  
        
        out = GibsonLaniPSF;
        end
        function out = d2dzp2(GibsonLaniPSF, x0in, y0in, zpin, lambdain)            
            GibsonLaniPSF.x0(:)=GibsonLaniPSF.M*single(x0in);
            
            GibsonLaniPSF.y0(:)=GibsonLaniPSF.M*single(y0in);
            
            GibsonLaniPSF.zp(:)=single(zpin);
            
            GibsonLaniPSF.lambda(:)=single(lambdain);
            
            Integral = GibsonLaniPSFModel(...
                GibsonLaniPSF.x,...
                GibsonLaniPSF.y,...
                GibsonLaniPSF.x0,...
                GibsonLaniPSF.y0,...
                GibsonLaniPSF.zp,...
                GibsonLaniPSF.lambda,...
                GibsonLaniPSF.NA,...
                GibsonLaniPSF.M,...
                GibsonLaniPSF.ns,...
                GibsonLaniPSF.ni,...
                GibsonLaniPSF.DELTAt,...
                GibsonLaniPSF.zd,...
                GibsonLaniPSF.zdstar,...
                GibsonLaniPSF.np,...
                GibsonLaniPSF.na,...
                GibsonLaniPSF.rho,...
                GibsonLaniPSF.theta,...
                GibsonLaniPSF.Bstar,...
                GibsonLaniPSF.THETAplate,...
                GibsonLaniPSF.THETAZernike...
            );
            
            ddzpIntegral = GibsonLaniPSFModelddzp(...
                GibsonLaniPSF.x,...
                GibsonLaniPSF.y,...
                GibsonLaniPSF.x0,...
                GibsonLaniPSF.y0,...
                GibsonLaniPSF.zp,...
                GibsonLaniPSF.lambda,...
                GibsonLaniPSF.NA,...
                GibsonLaniPSF.M,...
                GibsonLaniPSF.ns,...
                GibsonLaniPSF.ni,...
                GibsonLaniPSF.DELTAt,...
                GibsonLaniPSF.zd,...
                GibsonLaniPSF.zdstar,...
                GibsonLaniPSF.np,...
                GibsonLaniPSF.na,...
                GibsonLaniPSF.rho,...
                GibsonLaniPSF.theta,...
                GibsonLaniPSF.Bstar,...
                GibsonLaniPSF.THETAplate,...
                GibsonLaniPSF.THETAZernike...
            );
        
            d2dzp2Integral = GibsonLaniPSFModeld2dzp2(...
                GibsonLaniPSF.x,...
                GibsonLaniPSF.y,...
                GibsonLaniPSF.x0,...
                GibsonLaniPSF.y0,...
                GibsonLaniPSF.zp,...
                GibsonLaniPSF.lambda,...
                GibsonLaniPSF.NA,...
                GibsonLaniPSF.M,...
                GibsonLaniPSF.ns,...
                GibsonLaniPSF.ni,...
                GibsonLaniPSF.DELTAt,...
                GibsonLaniPSF.zd,...
                GibsonLaniPSF.zdstar,...
                GibsonLaniPSF.np,...
                GibsonLaniPSF.na,...
                GibsonLaniPSF.rho,...
                GibsonLaniPSF.theta,...
                GibsonLaniPSF.Bstar,...
                GibsonLaniPSF.THETAplate,...
                GibsonLaniPSF.THETAZernike...
            );
        
        ModelPSF=conj(Integral).*Integral;
        
        GibsonLaniPSF.d2dzp2PSF=(conj(d2dzp2Integral).*Integral+...
            2*conj(ddzpIntegral).*ddzpIntegral+...
            conj(Integral).*d2dzp2Integral)./sum(sum(ModelPSF));                  
        
        out = GibsonLaniPSF;
        end
        function out = d2dlambda2(GibsonLaniPSF, x0in, y0in, zpin, lambdain)            
            GibsonLaniPSF.x0(:)=GibsonLaniPSF.M*single(x0in);
            
            GibsonLaniPSF.y0(:)=GibsonLaniPSF.M*single(y0in);
            
            GibsonLaniPSF.zp(:)=single(zpin);
            
            GibsonLaniPSF.lambda(:)=single(lambdain);
            
            Integral = GibsonLaniPSFModel(...
                GibsonLaniPSF.x,...
                GibsonLaniPSF.y,...
                GibsonLaniPSF.x0,...
                GibsonLaniPSF.y0,...
                GibsonLaniPSF.zp,...
                GibsonLaniPSF.lambda,...
                GibsonLaniPSF.NA,...
                GibsonLaniPSF.M,...
                GibsonLaniPSF.ns,...
                GibsonLaniPSF.ni,...
                GibsonLaniPSF.DELTAt,...
                GibsonLaniPSF.zd,...
                GibsonLaniPSF.zdstar,...
                GibsonLaniPSF.np,...
                GibsonLaniPSF.na,...
                GibsonLaniPSF.rho,...
                GibsonLaniPSF.theta,...
                GibsonLaniPSF.Bstar,...
                GibsonLaniPSF.THETAplate,...
                GibsonLaniPSF.THETAZernike...
            );
            
            ddlambdaIntegral = GibsonLaniPSFModelddlambda(...
                GibsonLaniPSF.x,...
                GibsonLaniPSF.y,...
                GibsonLaniPSF.x0,...
                GibsonLaniPSF.y0,...
                GibsonLaniPSF.zp,...
                GibsonLaniPSF.lambda,...
                GibsonLaniPSF.NA,...
                GibsonLaniPSF.M,...
                GibsonLaniPSF.ns,...
                GibsonLaniPSF.ni,...
                GibsonLaniPSF.DELTAt,...
                GibsonLaniPSF.zd,...
                GibsonLaniPSF.zdstar,...
                GibsonLaniPSF.np,...
                GibsonLaniPSF.na,...
                GibsonLaniPSF.rho,...
                GibsonLaniPSF.theta,...
                GibsonLaniPSF.Bstar,...
                GibsonLaniPSF.THETAplate,...
                GibsonLaniPSF.THETAZernike...
            );
        
            d2dlambda2Integral = GibsonLaniPSFModeld2dlambda2(...
                GibsonLaniPSF.x,...
                GibsonLaniPSF.y,...
                GibsonLaniPSF.x0,...
                GibsonLaniPSF.y0,...
                GibsonLaniPSF.zp,...
                GibsonLaniPSF.lambda,...
                GibsonLaniPSF.NA,...
                GibsonLaniPSF.M,...
                GibsonLaniPSF.ns,...
                GibsonLaniPSF.ni,...
                GibsonLaniPSF.DELTAt,...
                GibsonLaniPSF.zd,...
                GibsonLaniPSF.zdstar,...
                GibsonLaniPSF.np,...
                GibsonLaniPSF.na,...
                GibsonLaniPSF.rho,...
                GibsonLaniPSF.theta,...
                GibsonLaniPSF.Bstar,...
                GibsonLaniPSF.THETAplate,...
                GibsonLaniPSF.THETAZernike...
            );
        
        ModelPSF=conj(Integral).*Integral;
        
        GibsonLaniPSF.d2dlambda2PSF=(conj(d2dlambda2Integral).*Integral+...
            2*conj(ddlambdaIntegral).*ddlambdaIntegral+...
            conj(Integral).*d2dlambda2Integral)./sum(sum(ModelPSF));                  
        
        out = GibsonLaniPSF;
        end
    end
end

function out = GibsonLaniPSFModel(x, y, x0, y0, zp, lambda,...
                            NA, M, ns, ni, DELTAt, zd, zdstar, np, na,...
                            rho, theta, Bstar, THETAplate, THETAZernike)
                        
% NA = numerical aperture
% M = Magnification
% x = horizontal (column-wise) coordinate in image plane
% x0 = center of PSF coordinate system in object space
% y = vertical (row-wise) coordinate in object space
% rho = radial polar coordinate in the pupil plane
% theta = angular polar coordinate in pupil plane
% lambda = wavlength
% ns = index of refraction of sample
% zp = z position in the sample plane of the emitter, object space
% ni = index of refcation of the cover slip
% DELTAt = distance between focal position and zero axial coordinate in 
%       the object plane
% zd = focal offset of the detector from the focal plane of the lens
%       system
% zdstar = the tube length of the imaging system before the detector
% np = the index of refraction of the phase plate
% THETAPlate = the actual topography of the phase plate in um
% ThetaZernike = the non-phase wrapped phase function of the super-position
%       of Zernike polynomial aberrations
% na = index of refraction of air

% this expression was converted to matlab code form mathematica code with
% the "ToMatlab" package in mathematica.

integrand = exp(1).^((sqrt(-1)*2).*lambda.^(-1).*pi.*((-1).*DELTAt.*ni.*(1+( ...
 -1).*NA.^2.*ni.^(-2).*rho.^2).^(1/2)+(-1).*(np-na).*THETAplate+(-1).* ...
  na.*THETAZernike+(-1/2).*rho.*zd.^(-1).*zdstar.^(-1).*((-1).*zd+ ...
  zdstar)+(-1).*ns.*(1+(-1).*NA.^2.*ns.^(-2).*rho.^2).^(1/2).*zp+ ...
  M.^(-1).*NA.*rho.*(((-1).*x+x0).^2+((-1).*y+y0).^2).^(1/2).*cos( ...
  theta+(-1).*atan2((-1).*x+x0,(-1).*y+y0)))).*lambda.^(-1).*M.^(-2) ...
  .*NA.^2.*rho;
integrand(isinf(integrand))=0;
integrand(isnan(integrand))=0;

out = sum(integrand.*complex(Bstar),3);
end

function out = GibsonLaniPSFModelddx0(x, y, x0, y0, zp, lambda,...
                            NA, M, ns, ni, DELTAt, zd, zdstar, np, na,...
                            rho, theta, Bstar, THETAplate, THETAZernike)
                        
% NA = numerical aperture
% M = Magnification
% x = horizontal (column-wise) coordinate in image plane
% x0 = center of PSF coordinate system in object space
% y = vertical (row-wise) coordinate in object space
% rho = radial polar coordinate in the pupil plane
% theta = angular polar coordinate in pupil plane
% lambda = wavlength
% ns = index of refraction of sample
% zp = z position in the sample plane of the emitter, object space
% ni = index of refcation of the cover slip
% DELTAt = distance between focal position and zero axial coordinate in 
%       the object plane
% zd = focal offset of the detector from the focal plane of the lens
%       system
% zdstar = the tube length of the imaging system before the detector
% np = the index of refraction of the phase plate
% THETAPlate = the actual topography of the phase plate in um
% ThetaZernike = the non-phase wrapped phase function of the super-position
%       of Zernike polynomial aberrations
% na = index of refraction of air

% this expression was converted to matlab code form mathematica code with
% the "ToMatlab" package in mathematica.

integrand = (sqrt(-1)*(-2)).*exp(1).^((sqrt(-1)*(-1)).*lambda.^(-1).*M.^(-1).* ...
  pi.*zd.^(-1).*zdstar.^(-1).*(M.*rho.*((-1).*zd+zdstar)+2.*M.*zd.* ...
  zdstar.*(DELTAt.*ni.*(1+(-1).*NA.^2.*ni.^(-2).*rho.^2).^(1/2)+(np-na).* ...
  THETAplate+na.*THETAZernike+ns.*(1+(-1).*NA.^2.*ns.^(-2).*rho.^2) ...
  .^(1/2).*zp)+(-2).*NA.*rho.*(x.^2+(-2).*x.*x0+x0.^2+(y+(-1).*y0) ...
  .^2).^(1/2).*zd.*zdstar.*cos(theta+(-1).*atan2((-1).*x+x0,(-1).*y+ ...
  y0)))).*lambda.^(-2).*M.^(-3).*NA.^3.*pi.*rho.^2.*((x+(-1).*x0) ...
  .^2+(y+(-1).*y0).^2).^(-1/2).*((x+(-1).*x0).*cos(theta+(-1).*atan2( ...
  (-1).*x+x0,(-1).*y+y0))+((-1).*y+y0).*sin(theta+(-1).*atan2((-1).* ...
  x+x0,(-1).*y+y0)));

integrand(isinf(integrand))=0;
integrand(isnan(integrand))=0;

out = sum(integrand.*complex(Bstar),3);
end

function out = GibsonLaniPSFModelddy0(x, y, x0, y0, zp, lambda,...
                            NA, M, ns, ni, DELTAt, zd, zdstar, np, na,...
                            rho, theta, Bstar, THETAplate, THETAZernike)
                        
% NA = numerical aperture
% M = Magnification
% x = horizontal (column-wise) coordinate in image plane
% x0 = center of PSF coordinate system in object space
% y = vertical (row-wise) coordinate in object space
% rho = radial polar coordinate in the pupil plane
% theta = angular polar coordinate in pupil plane
% lambda = wavlength
% ns = index of refraction of sample
% zp = z position in the sample plane of the emitter, object space
% ni = index of refcation of the cover slip
% DELTAt = distance between focal position and zero axial coordinate in 
%       the object plane
% zd = focal offset of the detector from the focal plane of the lens
%       system
% zdstar = the tube length of the imaging system before the detector
% np = the index of refraction of the phase plate
% THETAPlate = the actual topography of the phase plate in um
% ThetaZernike = the non-phase wrapped phase function of the super-position
%       of Zernike polynomial aberrations
% na = index of refraction of air

% this expression was converted to matlab code form mathematica code with
% the "ToMatlab" package in mathematica.

integrand = (sqrt(-1)*(-2)).*exp(1).^((sqrt(-1)*(-1)).*lambda.^(-1).*M.^(-1).* ...
  pi.*zd.^(-1).*zdstar.^(-1).*(M.*rho.*((-1).*zd+zdstar)+2.*M.*zd.* ...
  zdstar.*(DELTAt.*ni.*(1+(-1).*NA.^2.*ni.^(-2).*rho.^2).^(1/2)+(np-na).* ...
  THETAplate+na.*THETAZernike+ns.*(1+(-1).*NA.^2.*ns.^(-2).*rho.^2) ...
  .^(1/2).*zp)+(-2).*NA.*rho.*(x.^2+(-2).*x.*x0+x0.^2+(y+(-1).*y0) ...
  .^2).^(1/2).*zd.*zdstar.*cos(theta+(-1).*atan2((-1).*x+x0,(-1).*y+ ...
  y0)))).*lambda.^(-2).*M.^(-3).*NA.^3.*pi.*rho.^2.*((x+(-1).*x0) ...
  .^2+(y+(-1).*y0).^2).^(-1/2).*((y+(-1).*y0).*cos(theta+(-1).*atan2( ...
  (-1).*x+x0,(-1).*y+y0))+(x+(-1).*x0).*sin(theta+(-1).*atan2((-1).* ...
  x+x0,(-1).*y+y0)));

integrand(isinf(integrand))=0;
integrand(isnan(integrand))=0;

out = sum(integrand.*complex(Bstar),3);
end

function out = GibsonLaniPSFModelddzp(x, y, x0, y0, zp, lambda,...
                            NA, M, ns, ni, DELTAt, zd, zdstar, np, na,...
                            rho, theta, Bstar, THETAplate, THETAZernike)
                        
% NA = numerical aperture
% M = Magnification
% x = horizontal (column-wise) coordinate in image plane
% x0 = center of PSF coordinate system in object space
% y = vertical (row-wise) coordinate in object space
% rho = radial polar coordinate in the pupil plane
% theta = angular polar coordinate in pupil plane
% lambda = wavlength
% ns = index of refraction of sample
% zp = z position in the sample plane of the emitter, object space
% ni = index of refcation of the cover slip
% DELTAt = distance between focal position and zero axial coordinate in 
%       the object plane
% zd = focal offset of the detector from the focal plane of the lens
%       system
% zdstar = the tube length of the imaging system before the detector
% np = the index of refraction of the phase plate
% THETAPlate = the actual topography of the phase plate in um
% ThetaZernike = the non-phase wrapped phase function of the super-position
%       of Zernike polynomial aberrations
% na = index of refraction of air

% this expression was converted to matlab code form mathematica code with
% the "ToMatlab" package in mathematica.

integrand = (sqrt(-1)*(-2)).*exp(1).^((sqrt(-1)*2).*lambda.^(-1).*pi.*((-1).* ...
  DELTAt.*ni.*(1+(-1).*NA.^2.*ni.^(-2).*rho.^2).^(1/2)+(-1).*(np-na).* ...
  THETAplate+(-1).*na.*THETAZernike+(1/2).*rho.*zd.^(-1).*(zd+(-1).* ...
  zdstar).*zdstar.^(-1)+(-1).*ns.*(1+(-1).*NA.^2.*ns.^(-2).*rho.^2) ...
  .^(1/2).*zp+M.^(-1).*NA.*rho.*((x+(-1).*x0).^2+(y+(-1).*y0).^2).^( ...
  1/2).*cos(theta+(-1).*atan2((-1).*x+x0,(-1).*y+y0)))).*lambda.^(-2) ...
  .*M.^(-2).*NA.^2.*ns.*pi.*rho.*(1+(-1).*NA.^2.*ns.^(-2).*rho.^2) ...
  .^(1/2);

integrand(isinf(integrand))=0;
integrand(isnan(integrand))=0;

out = sum(integrand.*complex(Bstar),3);
end

function out = GibsonLaniPSFModelddlambda(x, y, x0, y0, zp, lambda,...
                            NA, M, ns, ni, DELTAt, zd, zdstar, np, na,...
                            rho, theta, Bstar, THETAplate, THETAZernike)
                        
% NA = numerical aperture
% M = Magnification
% x = horizontal (column-wise) coordinate in image plane
% x0 = center of PSF coordinate system in object space
% y = vertical (row-wise) coordinate in object space
% rho = radial polar coordinate in the pupil plane
% theta = angular polar coordinate in pupil plane
% lambda = wavlength
% ns = index of refraction of sample
% zp = z position in the sample plane of the emitter, object space
% ni = index of refcation of the cover slip
% DELTAt = distance between focal position and zero axial coordinate in 
%       the object plane
% zd = focal offset of the detector from the focal plane of the lens
%       system
% zdstar = the tube length of the imaging system before the detector
% np = the index of refraction of the phase plate
% THETAPlate = the actual topography of the phase plate in um
% ThetaZernike = the non-phase wrapped phase function of the super-position
%       of Zernike polynomial aberrations
% na = index of refraction of air

% this expression was converted to matlab code form mathematica code with
% the "ToMatlab" package in mathematica.

integrand = (sqrt(-1)*(-1)).*exp(1).^((sqrt(-1)*(-1)).*lambda.^(-1).*M.^(-1).* ...
  pi.*zd.^(-1).*zdstar.^(-1).*(M.*rho.*((-1).*zd+zdstar)+2.*M.*zd.* ...
  zdstar.*(DELTAt.*ni.*(1+(-1).*NA.^2.*ni.^(-2).*rho.^2).^(1/2)+(np-na).* ...
  THETAplate+na.*THETAZernike+ns.*(1+(-1).*NA.^2.*ns.^(-2).*rho.^2) ...
  .^(1/2).*zp)+(-2).*NA.*rho.*(x.^2+(-2).*x.*x0+x0.^2+(y+(-1).*y0) ...
  .^2).^(1/2).*zd.*zdstar.*cos(theta+(-1).*atan2((-1).*x+x0,(-1).*y+ ...
  y0)))).*lambda.^(-3).*M.^(-3).*NA.^2.*rho.*zd.^(-1).*zdstar.^(-1) ...
  .*(M.*(pi.*rho.*(zd+(-1).*zdstar)+(sqrt(-1)*(-1)).*lambda.*zd.* ...
  zdstar+(-2).*pi.*zd.*zdstar.*(DELTAt.*ni.*(1+(-1).*NA.^2.*ni.^(-2) ...
  .*rho.^2).^(1/2)+(np-na).*THETAplate+na.*THETAZernike+ns.*(1+(-1).* ...
  NA.^2.*ns.^(-2).*rho.^2).^(1/2).*zp))+2.*NA.*pi.*rho.*(x.^2+(-2).* ...
  x.*x0+x0.^2+(y+(-1).*y0).^2).^(1/2).*zd.*zdstar.*cos(theta+(-1).* ...
  atan2((-1).*x+x0,(-1).*y+y0)));

integrand(isinf(integrand))=0;
integrand(isnan(integrand))=0;

out = sum(integrand.*complex(Bstar),3);
end

function out = GibsonLaniPSFModeld2dx02(x, y, x0, y0, zp, lambda,...
                            NA, M, ns, ni, DELTAt, zd, zdstar, np, na,...
                            rho, theta, Bstar, THETAplate, THETAZernike)
                        
% NA = numerical aperture
% M = Magnification
% x = horizontal (column-wise) coordinate in image plane
% x0 = center of PSF coordinate system in object space
% y = vertical (row-wise) coordinate in object space
% rho = radial polar coordinate in the pupil plane
% theta = angular polar coordinate in pupil plane
% lambda = wavlength
% ns = index of refraction of sample
% zp = z position in the sample plane of the emitter, object space
% ni = index of refcation of the cover slip
% DELTAt = distance between focal position and zero axial coordinate in 
%       the object plane
% zd = focal offset of the detector from the focal plane of the lens
%       system
% zdstar = the tube length of the imaging system before the detector
% np = the index of refraction of the phase plate
% THETAPlate = the actual topography of the phase plate in um
% ThetaZernike = the non-phase wrapped phase function of the super-position
%       of Zernike polynomial aberrations
% na = index of refraction of air

% this expression was converted to matlab code form mathematica code with
% the "ToMatlab" package in mathematica.

integrand = (-4).*exp(1).^((sqrt(-1)*(-1)).*lambda.^(-1).*M.^(-1).*pi.*zd.^( ...
  -1).*zdstar.^(-1).*(M.*rho.*((-1).*zd+zdstar)+2.*M.*zd.*zdstar.*( ...
  DELTAt.*ni.*(1+(-1).*NA.^2.*ni.^(-2).*rho.^2).^(1/2)+(np-na).* ...
  THETAplate+na.*THETAZernike+ns.*(1+(-1).*NA.^2.*ns.^(-2).*rho.^2) ...
  .^(1/2).*zp)+(-2).*NA.*rho.*(x.^2+(-2).*x.*x0+x0.^2+(y+(-1).*y0) ...
  .^2).^(1/2).*zd.*zdstar.*cos(theta+(-1).*atan2((-1).*x+x0,(-1).*y+ ...
  y0)))).*lambda.^(-3).*M.^(-4).*NA.^4.*pi.^2.*rho.^3.*((x+(-1).*x0) ...
  .^2+(y+(-1).*y0).^2).^(-1).*((x+(-1).*x0).*cos(theta+(-1).*atan2(( ...
  -1).*x+x0,(-1).*y+y0))+((-1).*y+y0).*sin(theta+(-1).*atan2((-1).*x+ ...
  x0,(-1).*y+y0))).^2;

integrand(isinf(integrand))=0;
integrand(isnan(integrand))=0;

out = sum(integrand.*complex(Bstar),3);
end

function out = GibsonLaniPSFModeld2dy02(x, y, x0, y0, zp, lambda,...
                            NA, M, ns, ni, DELTAt, zd, zdstar, np, na,...
                            rho, theta, Bstar, THETAplate, THETAZernike)
                        
% NA = numerical aperture
% M = Magnification
% x = horizontal (column-wise) coordinate in image plane
% x0 = center of PSF coordinate system in object space
% y = vertical (row-wise) coordinate in object space
% rho = radial polar coordinate in the pupil plane
% theta = angular polar coordinate in pupil plane
% lambda = wavlength
% ns = index of refraction of sample
% zp = z position in the sample plane of the emitter, object space
% ni = index of refcation of the cover slip
% DELTAt = distance between focal position and zero axial coordinate in 
%       the object plane
% zd = focal offset of the detector from the focal plane of the lens
%       system
% zdstar = the tube length of the imaging system before the detector
% np = the index of refraction of the phase plate
% THETAPlate = the actual topography of the phase plate in um
% ThetaZernike = the non-phase wrapped phase function of the super-position
%       of Zernike polynomial aberrations
% na = index of refraction of air

% this expression was converted to matlab code form mathematica code with
% the "ToMatlab" package in mathematica.

integrand = (-4).*exp(1).^((sqrt(-1)*(-1)).*lambda.^(-1).*M.^(-1).*pi.*zd.^( ...
  -1).*zdstar.^(-1).*(M.*rho.*((-1).*zd+zdstar)+2.*M.*zd.*zdstar.*( ...
  DELTAt.*ni.*(1+(-1).*NA.^2.*ni.^(-2).*rho.^2).^(1/2)+(np-na).* ...
  THETAplate+na.*THETAZernike+ns.*(1+(-1).*NA.^2.*ns.^(-2).*rho.^2) ...
  .^(1/2).*zp)+(-2).*NA.*rho.*(x.^2+(-2).*x.*x0+x0.^2+(y+(-1).*y0) ...
  .^2).^(1/2).*zd.*zdstar.*cos(theta+(-1).*atan2((-1).*x+x0,(-1).*y+ ...
  y0)))).*lambda.^(-3).*M.^(-4).*NA.^4.*pi.^2.*rho.^3.*((x+(-1).*x0) ...
  .^2+(y+(-1).*y0).^2).^(-1).*((x+(-1).*x0).*cos(theta+(-1).*atan2(( ...
  -1).*x+x0,(-1).*y+y0))+((-1).*y+y0).*sin(theta+(-1).*atan2((-1).*x+ ...
  x0,(-1).*y+y0))).^2;

integrand(isinf(integrand))=0;
integrand(isnan(integrand))=0;

out = sum(integrand.*complex(Bstar),3);
end

function out = GibsonLaniPSFModeld2dzp2(x, y, x0, y0, zp, lambda,...
                            NA, M, ns, ni, DELTAt, zd, zdstar, np, na,...
                            rho, theta, Bstar, THETAplate, THETAZernike)
                        
% NA = numerical aperture
% M = Magnification
% x = horizontal (column-wise) coordinate in image plane
% x0 = center of PSF coordinate system in object space
% y = vertical (row-wise) coordinate in object space
% rho = radial polar coordinate in the pupil plane
% theta = angular polar coordinate in pupil plane
% lambda = wavlength
% ns = index of refraction of sample
% zp = z position in the sample plane of the emitter, object space
% ni = index of refcation of the cover slip
% DELTAt = distance between focal position and zero axial coordinate in 
%       the object plane
% zd = focal offset of the detector from the focal plane of the lens
%       system
% zdstar = the tube length of the imaging system before the detector
% np = the index of refraction of the phase plate
% THETAPlate = the actual topography of the phase plate in um
% ThetaZernike = the non-phase wrapped phase function of the super-position
%       of Zernike polynomial aberrations
% na = index of refraction of air

% this expression was converted to matlab code form mathematica code with
% the "ToMatlab" package in mathematica.

integrand = 4.*exp(1).^((sqrt(-1)*(-1)).*lambda.^(-1).*M.^(-1).*pi.*zd.^(-1).* ...
  zdstar.^(-1).*(M.*rho.*((-1).*zd+zdstar)+2.*M.*zd.*zdstar.*( ...
  DELTAt.*ni.*(1+(-1).*NA.^2.*ni.^(-2).*rho.^2).^(1/2)+(np-na).* ...
  THETAplate+na.*THETAZernike+ns.*(1+(-1).*NA.^2.*ns.^(-2).*rho.^2) ...
  .^(1/2).*zp)+(-2).*NA.*rho.*(x.^2+(-2).*x.*x0+x0.^2+(y+(-1).*y0) ...
  .^2).^(1/2).*zd.*zdstar.*cos(theta+(-1).*atan2((-1).*x+x0,(-1).*y+ ...
  y0)))).*lambda.^(-3).*M.^(-2).*NA.^2.*pi.^2.*rho.*((-1).*ns.^2+ ...
  NA.^2.*rho.^2);

integrand(isinf(integrand))=0;
integrand(isnan(integrand))=0;

out = sum(integrand.*complex(Bstar),3);
end

function out = GibsonLaniPSFModeld2dlambda2(x, y, x0, y0, zp, lambda,...
                            NA, M, ns, ni, DELTAt, zd, zdstar, np, na,...
                            rho, theta, Bstar, THETAplate, THETAZernike)
                        
% NA = numerical aperture
% M = Magnification
% x = horizontal (column-wise) coordinate in image plane
% x0 = center of PSF coordinate system in object space
% y = vertical (row-wise) coordinate in object space
% rho = radial polar coordinate in the pupil plane
% theta = angular polar coordinate in pupil plane
% lambda = wavlength
% ns = index of refraction of sample
% zp = z position in the sample plane of the emitter, object space
% ni = index of refcation of the cover slip
% DELTAt = distance between focal position and zero axial coordinate in 
%       the object plane
% zd = focal offset of the detector from the focal plane of the lens
%       system
% zdstar = the tube length of the imaging system before the detector
% np = the index of refraction of the phase plate
% THETAPlate = the actual topography of the phase plate in um
% ThetaZernike = the non-phase wrapped phase function of the super-position
%       of Zernike polynomial aberrations
% na = index of refraction of air

% this expression was converted to matlab code form mathematica code with
% the "ToMatlab" package in mathematica.

integrand = 2.*exp(1).^((sqrt(-1)*(-1)).*lambda.^(-1).*M.^(-1).*pi.*zd.^(-1).* ...
  zdstar.^(-1).*(M.*rho.*((-1).*zd+zdstar)+2.*M.*zd.*zdstar.*( ...
  DELTAt.*ni.*(1+(-1).*NA.^2.*ni.^(-2).*rho.^2).^(1/2)+(np-na).* ...
  THETAplate+na.*THETAZernike+ns.*(1+(-1).*NA.^2.*ns.^(-2).*rho.^2) ...
  .^(1/2).*zp)+(-2).*NA.*rho.*(x.^2+(-2).*x.*x0+x0.^2+(y+(-1).*y0) ...
  .^2).^(1/2).*zd.*zdstar.*cos(theta+(-1).*atan2((-1).*x+x0,(-1).*y+ ...
  y0)))).*lambda.^(-5).*M.^(-2).*NA.^2.*rho.*(lambda.^2+(sqrt(-1)*( ...
  -2)).*lambda.*M.^(-1).*pi.*zd.^(-1).*zdstar.^(-1).*(M.*rho.*((-1) ...
  .*zd+zdstar)+2.*M.*zd.*zdstar.*(DELTAt.*ni.*(1+(-1).*NA.^2.*ni.^( ...
  -2).*rho.^2).^(1/2)+(np-na).*THETAplate+na.*THETAZernike+ns.*(1+(-1).* ...
  NA.^2.*ns.^(-2).*rho.^2).^(1/2).*zp)+(-2).*NA.*rho.*(x.^2+(-2).* ...
  x.*x0+x0.^2+(y+(-1).*y0).^2).^(1/2).*zd.*zdstar.*cos(theta+(-1).* ...
  atan2((-1).*x+x0,(-1).*y+y0)))+(-1/2).*M.^(-2).*pi.^2.*zd.^(-2).* ...
  zdstar.^(-2).*(M.*rho.*((-1).*zd+zdstar)+2.*M.*zd.*zdstar.*( ...
  DELTAt.*ni.*(1+(-1).*NA.^2.*ni.^(-2).*rho.^2).^(1/2)+(np-na).* ...
  THETAplate+na.*THETAZernike+ns.*(1+(-1).*NA.^2.*ns.^(-2).*rho.^2) ...
  .^(1/2).*zp)+(-2).*NA.*rho.*(x.^2+(-2).*x.*x0+x0.^2+(y+(-1).*y0) ...
  .^2).^(1/2).*zd.*zdstar.*cos(theta+(-1).*atan2((-1).*x+x0,(-1).*y+ ...
  y0))).^2);

integrand(isinf(integrand))=0;
integrand(isnan(integrand))=0;

out = sum(integrand.*complex(Bstar),3);
end